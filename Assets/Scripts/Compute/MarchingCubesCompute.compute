#pragma kernel March
#pragma kernel UpdateDensity

// lookup tables for marching cubes algorithm
#include "./MarchingTable.hlsl"


RWStructuredBuffer<float> _DensityValues;

float _IsoLevel;
int _ChunkWidth;
int _ChunkHeight;

int _CubeSize;

float3 _HitPosition;
float _BrushSize;
float _TerraformStrength;


struct Triangle {
    float3 a, b, c;
};

AppendStructuredBuffer<Triangle> _Triangles;

int indexFromCoord(int x, int y, int z)
{
    x = x * _CubeSize;
    y = y * _CubeSize;
    z = z * _CubeSize;
    return x + (_ChunkWidth) * (y + (_ChunkHeight) * z);
}

float3 interp(float3 edgeVertex1, float valueAtVertex1, float3 edgeVertex2, float valueAtVertex2)
{
    float3 pos = (edgeVertex1 + (_IsoLevel - valueAtVertex1) * (edgeVertex2 - edgeVertex1) / (valueAtVertex2 - valueAtVertex1));
    // return (edgeVertex1 + edgeVertex2) * 0.5 * _CubeSize;
    pos *= _CubeSize;
    pos.y -= _CubeSize * 0.75;
    return pos;
}

bool vertexOnEdge(float3 vertex) {
    return vertex.x == 0 || vertex.x == _ChunkWidth - 1 || vertex.z == 0 || vertex.z == _ChunkWidth - 1;
};


[numthreads(8,8,8)]
void March(uint3 id : SV_DispatchThreadID)
{

    bool isLeftEdge = id.x * _CubeSize == 0;
    bool isRightEdge = id.x * _CubeSize >= _ChunkWidth - _CubeSize - 1;
    bool isUpEdge = id.z * _CubeSize >= _ChunkWidth - _CubeSize - 1;
    bool isDownEdge = id.z * _CubeSize == 0;

    bool isEdge = isRightEdge || isLeftEdge || isUpEdge || isDownEdge;

    // return if index out of range
    if (id.x * _CubeSize >= _ChunkWidth - _CubeSize || id.y * _CubeSize >= _ChunkHeight - _CubeSize || id.z * _CubeSize >= _ChunkWidth - _CubeSize)
        return;

    float cubeValues[8] = {
        _DensityValues[indexFromCoord(id.x, id.y, (id.z + 1))],
        _DensityValues[indexFromCoord((id.x + 1), id.y, (id.z + 1))],
        _DensityValues[indexFromCoord((id.x + 1), id.y, id.z)],
        _DensityValues[indexFromCoord(id.x, id.y, id.z)],
        _DensityValues[indexFromCoord(id.x, (id.y + 1), (id.z + 1))],
        _DensityValues[indexFromCoord((id.x + 1), (id.y + 1), (id.z + 1))],
        _DensityValues[indexFromCoord((id.x + 1), (id.y + 1), id.z)],
        _DensityValues[indexFromCoord(id.x, (id.y + 1), id.z)]
    };


    int cubeIndex = 0;
    if (cubeValues[0] < _IsoLevel) cubeIndex |= 1;
    if (cubeValues[1] < _IsoLevel) cubeIndex |= 2;
    if (cubeValues[2] < _IsoLevel) cubeIndex |= 4;
    if (cubeValues[3] < _IsoLevel) cubeIndex |= 8;
    if (cubeValues[4] < _IsoLevel) cubeIndex |= 16;
    if (cubeValues[5] < _IsoLevel) cubeIndex |= 32;
    if (cubeValues[6] < _IsoLevel) cubeIndex |= 64;
    if (cubeValues[7] < _IsoLevel) cubeIndex |= 128;

    if (cubeIndex == 0 || cubeIndex == 255) return;

    int edges[] = triTable[cubeIndex];

    for (int i = 0; edges[i] != -1; i += 3)
    {
        // First edge lies between vertex e00 and vertex e01
        int e00 = edgeConnections[edges[i]][0];
        int e01 = edgeConnections[edges[i]][1];

        // Second edge lies between vertex e10 and vertex e11
        int e10 = edgeConnections[edges[i + 1]][0];
        int e11 = edgeConnections[edges[i + 1]][1];

        // Third edge lies between vertex e20 and vertex e21
        int e20 = edgeConnections[edges[i + 2]][0];
        int e21 = edgeConnections[edges[i + 2]][1];

        Triangle tri;

        float3 v1 = interp(cornerOffsets[e00], cubeValues[e00], cornerOffsets[e01], cubeValues[e01]) + id * _CubeSize;
        float3 v2 = interp(cornerOffsets[e10], cubeValues[e10], cornerOffsets[e11], cubeValues[e11]) + id * _CubeSize;
        float3 v3 = interp(cornerOffsets[e20], cubeValues[e20], cornerOffsets[e21], cubeValues[e21]) + id * _CubeSize;

        tri.a = v1;
        tri.b = v2;
        tri.c = v3;

        _Triangles.Append(tri);

        // // height of wall seam around chunk
        // float h = _CubeSize;

        // if (vertexOnEdge(v1) && vertexOnEdge(v2))
        // {
        //     Triangle tri2;
        //     tri2.c = v1;
        //     tri2.b = v2;
        //     tri2.a = float3(v1.x, v1.y - h, v1.z);
        //     _Triangles.Append(tri2);

        //     Triangle tri3;
        //     tri3.c = v2;
        //     tri3.b = float3(v2.x, v2.y - h, v2.z);
        //     tri3.a = float3(v1.x, v1.y - h, v1.z);
        //     _Triangles.Append(tri3);
        // }

        // if (vertexOnEdge(v2) && vertexOnEdge(v3))
        // {
        //     Triangle tri2;
        //     tri2.c = v2;
        //     tri2.b = v3;
        //     tri2.a = float3(v2.x, v2.y - h, v2.z);
        //     _Triangles.Append(tri2);

        //     Triangle tri3;
        //     tri3.c = float3(v3.x, v3.y - h, v3.z);
        //     tri3.b = float3(v2.x, v2.y - h, v2.z);
        //     tri3.a = v3;
        //     _Triangles.Append(tri3);
        // }

        // if (vertexOnEdge(v3) && vertexOnEdge(v1))
        // {
        //     Triangle tri2;
        //     tri2.c = v3;
        //     tri2.b = v1;
        //     tri2.a = float3(v3.x, v3.y - h, v3.z);
        //     _Triangles.Append(tri2);

        //     Triangle tri3;
        //     tri3.c = v1;
        //     tri3.b = float3(v1.x, v1.y - h, v1.z);
        //     tri3.a = float3(v3.x, v3.y - h, v3.z);
        //     _Triangles.Append(tri3);
        // }

    }

}

[numthreads(8,8,8)]
void UpdateDensity( uint3 id : SV_DispatchThreadID )
{
    if (id.x >= _ChunkWidth - 1 || id.y >= _ChunkHeight - 1 || id.z >= _ChunkWidth - 1)
        return;

    if (distance(id, _HitPosition) <= _BrushSize)
    {
        _DensityValues[indexFromCoord(id.x, id.y, id.z)] += _TerraformStrength;
    }
}