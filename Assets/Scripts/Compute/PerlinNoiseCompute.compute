#pragma kernel GenerateNoise

static const uint numthreads = 8;

RWStructuredBuffer<float> _Values;

int _ChunkWidth;
int _ChunkHeight;
float _OffsetX;
float _OffsetZ;


int octaves;
float persistence;
float lacunarity;
float scale;
float groundLevel;


// returns index for _Values array from current coords
int indexFromCoord(int x, int y, int z)
{
    return x + _ChunkWidth * (y + _ChunkHeight * z);
}

// returns a pseudo-random float between 0 and 1
float rand(float2 position)
{
    return frac(sin(dot(position, float2(12.9898,78.233))) * 43758.5453);
}


// returns a pseudo-random angle from 0 to 2 * pi
float randomAngle(float2 position)
{
    return rand(position) * 2 * 3.1415;
}

// returns a pseudo-random unit length vector
float2 randomVector(float2 position)
{
    // position = position + 0.02;
    float angle = randomAngle(position);
    float2 vec = float2(cos(angle), sin(angle));
    return vec;
}


float2 fade(float2 t) {
    return t * t * t * (t * (t * 6 - 15) + 10);
}


float perlinNoise2D(float2 position, int frequency)
{
    float unit = _ChunkWidth / frequency;

    // get position of candidate point in a grid
    float2 gridID = floor(position / unit);
    float2 gridUV = frac(position / unit);

    // get grid cell of the candidate point
    float2 gridCell = gridID + gridUV;

    // find coords of grid corners
    float2 bl = gridID + float2(0,0);
    float2 br = gridID + float2(1,0);
    float2 tl = gridID + float2(0,1);
    float2 tr = gridID + float2(1,1);

    // find random vector (gradient) for each grid corner
    float2 gradBL = randomVector(bl);
    float2 gradBR = randomVector(br);
    float2 gradTL = randomVector(tl);
    float2 gradTR = randomVector(tr);

    // find displacement vectors from each corner to candidate point (offset vectors)
    float2 offsetBL = gridUV - float2(0,0);
    float2 offsetBR = gridUV - float2(1,0);
    float2 offsetTL = gridUV - float2(0,1);
    float2 offsetTR = gridUV - float2(1,1);

    // calculate dot products of gradient vectors and offset vectors
    float dotBL = dot(gradBL, offsetBL);
    float dotBR = dot(gradBR, offsetBR);
    float dotTL = dot(gradTL, offsetTL);
    float dotTR = dot(gradTR, offsetTR);

    // smooth out gridUVs
    gridUV = smoothstep(0.01, 1, gridUV);
    // gridUV = fade(gridUV);

    // interpolate between dot products
    float bottom = lerp(dotBL, dotBR, gridUV.x);
    float top = lerp(dotTL, dotTR, gridUV.x);
    float perlin = lerp(bottom, top, gridUV.y);

    return perlin;
}


// layered (fractal) perlin noise
float fractalNoise2D(float2 position, int octaves, float persistence, float lacunarity)
{
    float result = 0;
    float frequency = 1.2;
    float amplitude = 1;
    float maxValue = 0; // for normalization

    for (int i = 0; i < octaves; i++)
    {
        result += perlinNoise2D(position, frequency) * amplitude;

        // increase frequency and decrease amplitude each octave
        maxValue += amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    return result / maxValue;
}


[numthreads(numthreads, numthreads, numthreads)]
void GenerateNoise (uint3 id : SV_DispatchThreadID)
{
    // return if index out of range
    if (id.x > _ChunkWidth || id.y > _ChunkHeight || id.z > _ChunkWidth)
        {
            return;
        }

    // global coords accounting for chunk offset and noise scale
    float globalX = (id.x + _OffsetX) * (1 /scale);
    float globalZ = (id.z + _OffsetZ) * (1 / scale);

    // noise value
    float currentDensity = _ChunkHeight * fractalNoise2D(float2(globalX, globalZ), octaves, persistence, lacunarity) + groundLevel;

    float newDensity = id.y;

    // currently using a singular height for each xz coord to make a hilly terrain with no overhangs
    if (id.y <= currentDensity - 0.5)
    {
        newDensity = 0;
    } else if (id.y > currentDensity + 0.5)
    {
        newDensity = 1;
    } else if (id.y > currentDensity)
    {
        newDensity = id.y - currentDensity;
    } else if (id.y < currentDensity)
    {
        newDensity = currentDensity - id.y;
    }

    if (id.y <= 1)
    {
        newDensity = 1;
    }

    // assign density to array of noise values
    _Values[indexFromCoord(id.x, id.y, id.z)] = newDensity;

}